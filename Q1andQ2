%% Q1
%   z(x) = x1 + x2^2 - 1,
%   Y_i = z(x) + eps_i,  eps_i ~ N(0,1), i=1..m
% Prior: x ~ N(mu, I)
% We implement: log_post(data, x, mu)

rng(0,'twister');
true_x = [0.2; 1.1];
m = 20;
z_true = z_of_x(true_x);
y = z_true + randn(m,1);

mu_prior = [0; 0];

cands = [0.0  1.0;
         0.2  1.1;
         0.5  0.5]';
for k = 1:size(cands,2)
    xk = cands(:,k);
    lp = log_post(y, xk, mu_prior);
    fprintf('x = [%g, %g],  log-post (unnorm) = %.4f\n', xk(1), xk(2), lp);
end

function z = z_of_x(x)
    x = x(:);
    assert(numel(x)==2, 'x must be 2D');
    z = x(1) + x(2)^2 - 1;
end

function ll = log_lik(data, x)
    y = data(:);
    z = z_of_x(x);
    resid = y - z;
    ll = -0.5 * sum(resid.^2);
end

function lp = log_prior(x, mu)
    x  = x(:);  mu = mu(:);
    assert(numel(x)==2 && numel(mu)==2, 'x and mu must be 2D');
    d = x - mu;
    lp = -0.5 * (d.'*d);
end

function lpost = log_post(data, x, mu)
    lpost = log_lik(data, x) + log_prior(x, mu);
end

%% Q2
clear; clc; rng(1,'twister');

%(a)
true_x   = [1; 0];
m        = 50;
mu_X     = [0; 0];

z_true   = z_of_x(true_x);
y        = z_true + randn(m,1);

x1grid = linspace(-1.5, 2.0, 181);
x2grid = linspace(-1.5, 2.0, 181);
[X1,X2] = meshgrid(x1grid, x2grid);

Sy2 = sum(y.^2);  Sy = sum(y);  mm = m;
Zgrid = X1 + X2.^2 - 1;
SSE   = Sy2 - 2*Zgrid*Sy + mm*(Zgrid.^2);
LP    = -0.5 * SSE - 0.5*((X1-mu_X(1)).^2 + (X2-mu_X(2)).^2);

LP_h        = LP;
LP_h(X2<=pi/2) = -inf;

figure('Name','Q2 (a): contours');
tiledlayout(1,2,'Padding','compact','TileSpacing','compact');

nexttile;
contourf(X1,X2,LP,18,'LineStyle','none'); colorbar;
xlabel('x_1'); ylabel('x_2'); title('Unnormalised log posterior (const dropped)');
hold on; yline(pi/2,'r--','\pi/2');

nexttile;
contourf(X1,X2,LP_h,18,'LineStyle','none'); colorbar;
xlabel('x_1'); ylabel('x_2'); title('log posterior * h(x) (x_2 > \pi/2 only)');
hold on; yline(pi/2,'r--','\pi/2');

%(b)

%(c) n = 1e3,1e4,1e5,1e6
n_list = [1e3, 1e4, 1e5, 1e6];
P_est  = zeros(size(n_list));
ESS1   = zeros(size(n_list));
ESSh   = zeros(size(n_list));

for t = 1:numel(n_list)
    n = n_list(t);
    out = snis_indicator(y, mu_X, n);
    P_est(t) = out.Phat;
    ESS1(t)  = out.ESS1;
    ESSh(t)  = out.ESSh;
    fprintf('n=%g  -->  P̂=%.6f,  ESS1=%.0f (%.1f%% of n),  ESS_h=%.0f (%.1f%% of n)\n', ...
        n, P_est(t), ESS1(t), 100*ESS1(t)/n, ESSh(t), 100*ESSh(t)/n);
end

figure('Name','Q2 (c): ESS vs n');
loglog(n_list, ESS1,'-o', n_list, ESSh,'-s','LineWidth',1.2); grid on;
xlabel('n'); ylabel('ESS'); legend('ESS_1 (posterior)','ESS_h (for E[h])','Location','northwest');
title('ESS scaling with sample size n (SNIS with prior as proposal)');

%(d) 100
R = 100;
sd_est = zeros(size(n_list));
for t = 1:numel(n_list)
    n = n_list(t);
    Phats = zeros(R,1);
    for r = 1:R
        out = snis_indicator(y, mu_X, n);
        Phats(r) = out.Phat;
    end
    sd_est(t) = std(Phats, 1);
    fprintf('[replicates] n=%g: mean(P̂)=%.6f, sd(P̂)=%.6g\n', n, mean(Phats), sd_est(t));
end

figure('Name','Q2 (d): SD vs n');
loglog(n_list, sd_est,'-^','LineWidth',1.2); grid on;
xlabel('n'); ylabel('SD of estimator across 100 runs');
title('Monte Carlo SD of SNIS estimator vs n');

%function
function out = snis_indicator(y, mu, n)
    m  = numel(y);
    Sy = sum(y);  Sy2 = sum(y.^2);
    % Z ~ N(mu, I)
    Z  = mu(:).' + randn(n,2);
    % z(x) & SSE
    z  = Z(:,1) + Z(:,2).^2 - 1; 
    SSE= Sy2 - 2*z*Sy + m*(z.^2);
    % log weight = log lik = -0.5 * SSE
    lw = -0.5 * SSE;
    lw = lw - max(lw);
    w  = exp(lw);
    wsum = sum(w);
    wnorm = w / wsum;

    h = double(Z(:,2) > pi/2);

    % SNIS estimate: sum h*w / sum w  = sum h*wnorm
    Phat = sum(h .* wnorm);

    % ESS_1
    ESS1 = 1.0 / sum(wnorm.^2);

    % ESS_h
    wh = h .* w;  s = sum(wh);
    if s==0
        ESSh = 0;
    else
        wh_norm = wh / s;
        ESSh = 1.0 / sum(wh_norm.^2);
    end

    out = struct('Phat',Phat,'ESS1',ESS1,'ESSh',ESSh);
end
